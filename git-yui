#!/usr/bin/env python

import os, sys, string, shutil, urllib2, urllib, pprint
from cStringIO import StringIO
from subprocess import call, CalledProcessError, PIPE

pp = pprint.PrettyPrinter(indent=4)

supported_projects = [
    'yui2',
    'yui3',
    'yuidoc',
    'builder'
]

args = []
count = 0
origin = None
git_config = {}
action = None
git_dir = None


for arg in sys.argv:
    if count > 0:
        if not action:
            action = arg
        args.append(arg)

    count = count + 1


def bold(str):
    return "\033[1m%s\033[0m" % str

def red(str):
    return "\033[31m%s\033[0m" % str

def print_error(str):
    print  bold(red(str))
    sys.exit(1)

def fetchGitConfig():
    raw_config = os.popen('git config --list').read().split("\n")
    for i in raw_config:
        line = i.split('=')
        if line[0]:
            git_config[line[0]] = line[1]

def fetchProject():
    if 'remote.origin.url' in git_config:
        org_remote = git_config['remote.origin.url'].replace('git@github.com:', '')
        remote = org_remote.replace('git://github.com/', '')
        remote = remote.replace('http://github.com:', '')
        remote = remote.replace('.git', '')
        remote = remote.split('/')
        if not remote[1]:
            print_error('Remote not found: %s' % org_remote)

        if remote[1] not in supported_projects:
            print_error('Remote (%s) not in supported projects list: %s' % (remote[1], ",".join(supported_projects)))
            
        return remote[1]
    else:
        print_error('No remote origin found, are we in a git repo?')

def fetchUpstream(master, user=None):
    if not user:
        user = 'yui'
    print "%s %s/%s" % (bold("Syncing with the upstream master:"), user, master)
    f_name = '%s_%s' % (user, master)
    remote_name = 'remote.%s.url' % f_name

    if not remote_name in git_config:
        call(['git', 'remote', 'add', f_name, 'git://github.com/%s/%s.git' % (user, master)])
    
    use_branch = True
    if 'yui.usebranch' in git_config:
        if git_config['yui.usebranch'] == 'false':
            use_branch = False

    if use_branch:
        retcode = call(['git', 'checkout', '-b', f_name], stderr=error_file)
        if retcode == 128:
            retcode = call(['git', 'checkout', f_name])
    else:
        retcode = call(['git', 'checkout', 'master'])
            
        
    if retcode == 0:
        retcode = call(['git', 'fetch', 'origin', '-v'])
        if retcode == 0:
            retcode = call(['git', 'fetch', f_name, '-v'])
            if retcode == 0:
                retcode = call(['git', 'merge', '%s/master' % f_name])
            else:
                call(['git', 'checkout', 'master'])
                call(['git', 'branch', '-d', f_name])
                print_error('Bad username given, branch %s deleted' % f_name)


def mergeUpstream(master, user):
    if not user:
        user = 'yui'
    print "%s %s/%s" % (bold("Merging into master:"), user, master)
    f_name = '%s_%s' % (user, master)

    retcode = call(['git', 'checkout', 'master'])
    if retcode == 0:
        retcode = call(['git', 'merge', f_name])
        

def checkAnt():
    try:
        call(['ant', '-version'], stdout=PIPE)
    except OSError:
        print_error('Ant was not found, please install it: http://ant.apache.org/')
    
    return True


def findGitRoot():
    if globals()["git_dir"]:
        return globals()["git_dir"]

    dir = os.path.abspath('.')
    check = os.path.join(dir, '.git')
    tmp_git_dir = None
    if os.path.exists(check):
        tmp_git_dir = check

    while not tmp_git_dir:
        dir = os.path.abspath(os.path.join(dir, '../'))
        check = os.path.join(dir, '.git')
        if os.path.exists(check):
            tmp_git_dir = check
    
    globals()["git_dir"] = os.path.abspath(os.path.join(tmp_git_dir, '../'))

    error_file_path = os.path.abspath(os.path.join(tmp_git_dir, 'yuilog'))
    if os.path.exists(error_file_path):
        os.rename(
            os.path.abspath(error_file_path), 
            os.path.abspath(os.path.join(tmp_git_dir, 'yuilog.last'))
        )
        globals()["error_file_path_last"] = os.path.abspath(os.path.join(tmp_git_dir, 'yuilog.last'))
        
    globals()["error_file_path"] = error_file_path
    globals()["error_file"] = open(error_file_path, 'w+')
    

def buildFromSource(item):
    src_path = os.path.abspath(os.path.join(git_dir, 'src/%s' % item))
    if not os.path.exists(src_path):
        print_error("Source Directory Not Found: \n%s" % src_path)

    os.chdir(src_path)

    print bold("Building source in: %s." % red(item))
    #TODO - Once Matt fixes his build environment, this can be removed..
    if os.path.isfile(os.path.join('', 'build.sh')):
        print bold(red('Control skipped (%s): found a build.sh file' % item))
    else:
        if os.path.isfile(os.path.join('', 'build.xml')):
            call(['ant', '-q', 'all'], stderr=error_file, stdout=error_file)
            print bold("Source for %s has been built." % item)
        else:
            print bold(red("No build.xml file found.."))


def getSrcDirs():
    src_path = os.path.abspath(os.path.join(git_dir, 'src/'))
    os.chdir(src_path)
    subdirs = []    
    for i in os.listdir(src_path):
        # Checking for directories that start with a '.'
        # Windows doesn't hide these directories by default
        if not i.startswith('.'):
            # Checking for known bad directory: CVS
            if i != 'CVS':
                fullname = os.path.join(src_path, i)
                if os.path.isdir(fullname):
                    subdirs.append(i)
    
    return subdirs

def buildAllFromSource():
    print bold("Building all from source..")
    subdirs = getSrcDirs()
    for i in subdirs:
        buildFromSource(i)

def checkBuilder():
    build_dir = os.path.abspath(os.path.join(git_dir, '../builder'))
    if not os.path.exists(build_dir):
        print_error('Builder module was not found. Please install it: http://github.com/yui/builder')
    
def checkYUIDoc():
    yuidoc_dir = os.path.abspath(os.path.join(git_dir, '../yuidoc'))
    if not os.path.exists(yuidoc_dir):
        print_error('YUIDoc module was not found. Please install it: http://github.com/yui/yuidoc')

    globals()['doc_dir'] = os.path.abspath(os.path.join(yuidoc_dir, 'bin'))
    
def buildControl(item):
    checkAnt()
    checkBuilder()

    if item == 'all':
        buildAllFromSource()
    else:
        buildFromSource(item)

def genDocs(items):
    prepDocParse()
    paths = []
    
    for i in items:
        src_path = os.path.abspath(os.path.join(git_dir, 'src/%s/js' % i))
        if os.path.exists(src_path):
            paths.append(src_path)


    print bold('Generating docs...')
    ver = origin.replace('yui', '')
    args = [os.path.join(doc_dir, 'yuidoc.py')]
    args2 = ['-p', os.path.join(doc_base_path, 'parser'),
        '-o', os.path.join(doc_base_path, 'html'),
        '-t', os.path.abspath(os.path.join(doc_dir, '../', 'template')),
        '-v', '1.0.0',
        '-Y', ver]
    ##Put all the pieces together
    for i in paths:
        args.append(i)
    for i in args2:
        args.append(i)

    retcode = call(args, stderr=error_file, stdout=error_file)
    if retcode > 0:
        print_error('Docs failed to parse. Call "git yui log" to see the error')
    print bold('Docs generated')


def genAllDocs():
    print bold('Generating all docs')
    subdirs = getSrcDirs()
    genDocs(subdirs)

def prepDocParse():
    src_path = os.path.abspath(os.path.join(git_dir, '../yui-docs'))
    if not os.path.exists(src_path):
        globals()['doc_base_path'] = src_path
        os.mkdir(os.path.abspath(src_path))
        os.mkdir(os.path.abspath(os.path.join(src_path, 'html')))
        os.mkdir(os.path.abspath(os.path.join(src_path, 'parser')))
    else:
        print_error('Docs directory exists. Please run: git yui doc clean')

def clearDocs():
    src_path = os.path.abspath(os.path.join(git_dir, '../yui-docs'))
    if os.path.exists(src_path):
        shutil.rmtree(src_path, ignore_errors=True) 
        print bold("Old docs directory removed.")
    else:
        print bold("No directory to clean")
       
    


def buildDocs(item):
    checkYUIDoc()

    if item[0] == 'all':
        genAllDocs()
    elif item[0] == 'clean':
        clearDocs()
    else:
        genDocs(item)

def showLog():
    f = open(error_file_path_last)
    print f.read()
    

########ACTION CODE STARTS HERE

fetchGitConfig()
findGitRoot()
origin = fetchProject()


##Process the arguments.. Maybe a better way?
##Don't want to use OptionParser, don't want to require the use of - arguments
if action == 'up':
    user = None
    if count > 2:
        user = args[1]
    fetchUpstream(origin, user)
elif action == 'merge':
    use_branch = True
    if 'yui.usebranch' in git_config:
        if git_config['yui.usebranch'] == 'false':
            use_branch = False
    
    if not use_branch:
        print_error('usebranch is false in config, this will do nothing.')
    user = None
    if count > 2:
        user = args[1]
    mergeUpstream(origin, user)
elif action == 'build':
    if count > 2:
        buildControl(args[1])
    else:
        print_error('You must provide a component name')
elif action == 'docs' or action == 'doc':
    if count > 2:
        items = []
        for k,v in enumerate(args):
            if k > 0:
                items.append(v)
        buildDocs(items)
    else:
        print_error('You must provide at least one component name')
elif action == 'log':
    showLog()
else:
    print bold("This helper app will help you develop and contribute to YUI.")
    print " Usage: git yui <action>"
    print bold("     git yui up")
    print "         This will pull the latest changes from yui HEAD into a branch called yui_<project>"
    print ""
    print bold("     git yui up <github username>")
    print "         This will pull the latest changes from <username> HEAD into a branch called <username>_<project>"
    print ""
    print bold("     git yui merge")
    print "         This will merge the yui_<project> branch back into the master branch"
    print ""
    print bold("     git yui merge <github username>")
    print "         This will merge the <username>_<project> branch back into the master branch"
    print ""
    print bold("     git yui build <control>")
    print bold("         git yui build dd")
    print "         This will run the ant processes needed to build the control"
    print ""
    print bold("         git yui build all")
    print "         This will run the build on all dir's in src."
    print ""
    print bold("     git yui docs <control1> <control2>")
    print bold("         git yui docs dd")
    print bold("         git yui docs dd anim node yui")
    print "         Build the API docs for the specified modules"
    print ""
    print bold("         git yui docs all")
    print "         Build the API docs for all modules"
    print ""
    print bold("     git yui log")
    print "         Show the error (stderr) output of the last command."
