#!/usr/bin/env python

import os, sys, string, shutil, urllib2, urllib, pprint, simplejson
from cStringIO import StringIO
from subprocess import call, PIPE

##Setup pp for debugging
pp = pprint.PrettyPrinter(indent=4)

##The supported projects, if not in this list, this script doesn't work
supported_projects = [
    'yui2',
    'yui3',
    'yuidoc',
    'builder'
]

##Globals
args = []
count = 0
username = None
origin = None
git_config = {}
action = None
git_dir = None
build_dir = None
member_list = None

##Process the Arguments
for arg in sys.argv:
    if count > 0:
        if not action:
            action = arg
        args.append(arg)

    count = count + 1


##Format bold text
def bold(str):
    return "\033[1m%s\033[0m" % str

##Format red text (for errors)
def red(str):
    return "\033[31m%s\033[0m" % str

##Print and format an error, then exit the script
def print_error(str):
    print  bold(red(str))
    sys.exit(1)

##Fetch the git config and place it in the git_config global
def fetchGitConfig():
    raw_config = os.popen('git config --list').read().split("\n")
    for i in raw_config:
        line = i.split('=')
        if line[0]:
            git_config[line[0]] = line[1]

##Fetch the list of users that forked this project
def fetchMembersList():
    if globals()['member_list']:
        return
    url = "http://github.com/yui/%s/network/members.json" % origin
    data = simplejson.load(urllib.urlopen(url))
    out = [];
    for i in data['users']:
        out.append(i['owner']['login'])

    globals()['member_list'] = out

##Parse the project out of the git config
def fetchProject():
    if 'remote.origin.url' in git_config:
        org_remote = git_config['remote.origin.url'].replace('git@github.com:', '')
        remote = org_remote.replace('git://github.com/', '')
        remote = remote.replace('http://github.com:', '')
        remote = remote.replace('.git', '')
        remote = remote.split('/')
        if not remote[1]:
            print_error('Remote not found: %s' % org_remote)

        if remote[1] not in supported_projects:
            print_error('Remote (%s) not in supported projects list: %s' % (remote[1], ",".join(supported_projects)))
        

        if git_config['user.email']:
            globals()['username'] = git_config['user.email']

        return remote[1]
    else:
        print_error('No remote origin found, are we in a git repo?')

##Fetch the upstream code and drop it in to a branch
def fetchUpstream(master, user=None):
    if not user:
        user = 'yui'
    print "%s %s/%s" % (bold("Syncing with the upstream master:"), user, master)
    f_name = '%s_%s' % (user, master)
    remote_name = 'remote.%s.url' % f_name

    if not remote_name in git_config:
        call(['git', 'remote', 'add', f_name, 'git://github.com/%s/%s.git' % (user, master)])
    
    use_branch = True
    if 'yui.usebranch' in git_config:
        if git_config['yui.usebranch'] == 'false':
            use_branch = False

    if use_branch:
        retcode = call(['git', 'checkout', '-b', f_name], stderr=error_file)
        if retcode == 128:
            retcode = call(['git', 'checkout', f_name])
    else:
        retcode = call(['git', 'checkout', 'master'])
            
        
    if retcode == 0:
        retcode = call(['git', 'fetch', 'origin', '-v'])
        if retcode == 0:
            retcode = call(['git', 'fetch', f_name, '-v'])
            if retcode == 0:
                retcode = call(['git', 'merge', '%s/master' % f_name])
            else:
                call(['git', 'checkout', 'master'])
                call(['git', 'branch', '-d', f_name])
                print_error('Bad username given, branch %s deleted' % f_name)

##Merge the upstream back into master
def mergeUpstream(master, user):
    if not user:
        user = 'yui'
    print "%s %s/%s" % (bold("Merging into master:"), user, master)
    f_name = '%s_%s' % (user, master)

    retcode = call(['git', 'checkout', 'master'])
    if retcode == 0:
        retcode = call(['git', 'merge', f_name])
        
##Check if the builder project is above the git root
def checkBuilder():
    build_dir = os.path.abspath(os.path.join(git_dir, '../builder'))
    if not os.path.exists(build_dir):
        print_error('Builder module was not found. Please install it: http://github.com/yui/builder')

    globals()['build_dir'] = build_dir
    
##Check if the yuidoc project is above the git root
def checkYUIDoc():
    yuidoc_dir = os.path.abspath(os.path.join(git_dir, '../yuidoc'))
    if not os.path.exists(yuidoc_dir):
        print_error('YUIDoc module was not found. Please install it: http://github.com/yui/yuidoc')

    globals()['doc_dir'] = os.path.abspath(os.path.join(yuidoc_dir, 'bin'))

##Check if ant is installed
def checkAnt():
    try:
        call(['ant', '-version'], stdout=PIPE)
    except OSError:
        print_error('Ant was not found, please install it: http://ant.apache.org/')
    
    return True

##Check if java is installed
def checkJava():
    try:
        call(['java', '-version'], stdout=PIPE, stderr=PIPE)
    except OSError:
        print_error('Java was not found, please install it')

    return True

##Find the root of this project, the one with the .git as a direct child.
def findGitRoot():
    if globals()["git_dir"]:
        return globals()["git_dir"]

    dir = os.path.abspath('.')
    check = os.path.join(dir, '.git')
    tmp_git_dir = None
    if os.path.exists(check):
        tmp_git_dir = check

    while not tmp_git_dir:
        dir = os.path.abspath(os.path.join(dir, '../'))
        check = os.path.join(dir, '.git')
        if os.path.exists(check):
            tmp_git_dir = check
    
    globals()["git_dir"] = os.path.abspath(os.path.join(tmp_git_dir, '../'))

    error_file_path = os.path.abspath(os.path.join(tmp_git_dir, 'yuilog'))
    if os.path.exists(error_file_path):
        os.rename(
            os.path.abspath(error_file_path), 
            os.path.abspath(os.path.join(tmp_git_dir, 'yuilog.last'))
        )
        globals()["error_file_path_last"] = os.path.abspath(os.path.join(tmp_git_dir, 'yuilog.last'))
        
    globals()["error_file_path"] = error_file_path
    globals()["error_file"] = open(error_file_path, 'w+')
    
##Build this item from source
def buildFromSource(item):
    src_path = os.path.abspath(os.path.join(git_dir, 'src/%s' % item))
    if not os.path.exists(src_path):
        print_error("Source Directory Not Found: \n%s" % src_path)

    os.chdir(src_path)

    print bold("Building source in: %s." % red(item))
    #TODO - Once Matt fixes his build environment, this can be removed..
    if os.path.isfile(os.path.join('', 'build.sh')):
        print bold(red('Control skipped (%s): found a build.sh file' % item))
    else:
        if os.path.isfile(os.path.join('', 'build.xml')):
            call(['ant', '-q', 'all'], stderr=error_file, stdout=error_file)
            print bold("Source for %s has been built." % item)
        else:
            print bold(red("No build.xml file found.."))

##Get all the source directories, so we can build them
def getSrcDirs():
    src_path = os.path.abspath(os.path.join(git_dir, 'src/'))
    os.chdir(src_path)
    subdirs = []    
    for i in os.listdir(src_path):
        # Checking for directories that start with a '.'
        # Windows doesn't hide these directories by default
        if not i.startswith('.'):
            # Checking for known bad directory: CVS
            if i != 'CVS':
                fullname = os.path.join(src_path, i)
                if os.path.isdir(fullname):
                    subdirs.append(i)
    
    return subdirs

##Build all from source
def buildAllFromSource():
    print bold("Building all from source..")
    subdirs = getSrcDirs()
    for i in subdirs:
        buildFromSource(i)

##Handle the build arg
def buildControl(item):
    checkAnt()
    checkBuilder()

    if item == 'all':
        buildAllFromSource()
    else:
        buildFromSource(item)

##Generate the docs for a groups of modules
def genDocs(items):
    prepDocParse()
    paths = []
    
    for i in items:
        src_path = os.path.abspath(os.path.join(git_dir, 'src/%s/js' % i))
        if os.path.exists(src_path):
            paths.append(src_path)


    print bold('Generating docs...')
    ver = origin.replace('yui', '')
    args = [os.path.join(doc_dir, 'yuidoc.py')]
    args2 = ['-p', os.path.join(doc_base_path, 'parser'),
        '-o', os.path.join(doc_base_path, 'html'),
        '-t', os.path.abspath(os.path.join(doc_dir, '../', 'template')),
        '-v', '1.0.0',
        '-Y', ver]
    ##Put all the pieces together
    for i in paths:
        args.append(i)
    for i in args2:
        args.append(i)

    retcode = call(args, stderr=error_file, stdout=error_file)
    if retcode > 0:
        print_error('Docs failed to parse. Call "git yui log" to see the error')
    print bold('Docs generated')

##Generate all the docs
def genAllDocs():
    print bold('Generating all docs')
    subdirs = getSrcDirs()
    genDocs(subdirs)

##Prep for doc parsing, setting up directories
def prepDocParse():
    src_path = os.path.abspath(os.path.join(git_dir, '../yui-docs'))
    if not os.path.exists(src_path):
        globals()['doc_base_path'] = src_path
        os.mkdir(os.path.abspath(src_path))
        os.mkdir(os.path.abspath(os.path.join(src_path, 'html')))
        os.mkdir(os.path.abspath(os.path.join(src_path, 'parser')))
    else:
        print_error('Docs directory exists. Please run: git yui doc clean')

##Remove the current docs directory
def clearDocs():
    src_path = os.path.abspath(os.path.join(git_dir, '../yui-docs'))
    if os.path.exists(src_path):
        shutil.rmtree(src_path, ignore_errors=True) 
        print bold("Old docs directory removed.")
    else:
        print bold("No directory to clean")

##Handle the docs argument
def buildDocs(item):
    checkYUIDoc()

    if item[0] == 'all':
        genAllDocs()
    elif item[0] == 'clean':
        clearDocs()
    else:
        genDocs(item)

##Handle the log argument
def showLog():
    f = open(error_file_path_last)
    print f.read()
    
##handle the lint argument
def lintFiles(items):
    for i in items:
        lintFile(i)

##Run JSLint on a file
def lintFile(file):
    if not os.path.exists(file):
        print_error('File not found')
    if not file.endswith('.js'):
        print_error('File is not a JavaScript file.')

    checkJava()
    checkBuilder()
    c_build = os.path.abspath(os.path.join(build_dir, 'componentbuild', 'lib'))
    jar_path = os.path.abspath(os.path.join(c_build, 'rhino', 'js.jar'))
    console_path = os.path.abspath(os.path.join(c_build, 'jslint', 'jslint-console.js'))
    full_path = os.path.abspath(os.path.join(c_build, 'jslint', 'fulljslint.js'))
    args = ['java', '-jar', jar_path, console_path, full_path, file]
    call(args)

##Show the list of forks for this project
def showNetwork():
    fetchMembersList()
    list = member_list
    list.sort()
    ##This need to move to an API call on yuilibrary.com
    contribs = [
        'davglass',
        'msweeney',
        'miraglia',
        'nzakas',
        'apm',
        'jlecomte',
        'lsmith',
        'jenny',
        'sdesai',
        'kloots',
        'g13n',
        'mlinac',
        'gmoothart',
        'emergence',
        'ebi',
        'Satyam',
        'bluesmoon',
        'caridy',
        'cgriego',
        'foxxtrot'
    ]
    contribs.sort()
    print bold("List of forks for: %s" % origin)
    print "Known contributors are bolded and marked with an *"
    print bold('yui')
    for i in contribs:
        if i in list:
            print bold("%s*" % i)
    for i in list:
        if not i in contribs and i != 'yui':
            print i

##Show your last (n) commits and their SHA1's
def showCommits(num):
    print bold('Showing your last %s commits' % num)
    args = [
        'git',
        '--no-pager',
        'log',
        '--author=%s' % username,
        '--no-merges',
        '--pretty=oneline',
        '-n%s' % num
    ]
    call(args)

##Issue a Pull Request to yui on GitHub
def pullRequest(commitid):
    print "%s %s" % (bold('Sending YUI a Pull Request for: '), commitid[0:8])
    
    try:
        username = git_config['github.user']
        token = git_config['github.token']
    except KeyError:
        print_error("No GitHub username or GitHub token in your git config.\nhttp://github.com/guides/tell-git-your-user-name-and-email-address")
    
    out = {}
    out['login'] = username
    out['token'] = token
    out['message[to][]'] = ''
    out['message[to][]'] = 'davglass'

    print bold('Please add a (one line) comment to this request:')

    comment = sys.stdin.readline().strip()
    if not comment:
        print bold(red('You must add a comment to the request.'))
        comment = sys.stdin.readline().strip()
        if not comment:
            print_error('No comment given, Pull Request failed.')

    out['message[body]'] = comment

    print bold('Are you sure you wish to make a Pull Request for %s/%s? [Y/n]' % (origin, commitid[0:8]))
    go = sys.stdin.readline().strip().lower()

    if go[0:1] == 'y':
        print bold('Sending Pull Request to GitHub')
        url = "http://github.com/%s/%s/pull_request/%s" % (username, origin, commitid)
        data = urllib.urlencode(out)
        req = urllib2.Request(url, data)
        response = urllib2.urlopen(req)
        
        ##There seems to be no way to tell if it was successful or not
        print bold('Pull Request sent')
    else:
        print_error('Pull Request cancelled')
    


########ACTION CODE STARTS HERE

fetchGitConfig()
findGitRoot()
origin = fetchProject()



##Process the arguments.. Maybe a better way?
##I don't want to use OptionParser, don't want to require the use of - arguments
if action == 'up':
    user = None
    if count > 2:
        fetchMembersList()
        user = args[1]
        if not user in member_list:
            print_error('User (%s) not in network' % user)
    fetchUpstream(origin, user)
elif action == 'merge':
    use_branch = True
    if 'yui.usebranch' in git_config:
        if git_config['yui.usebranch'] == 'false':
            use_branch = False
    
    if not use_branch:
        print_error('usebranch is false in config, this will do nothing.')
    user = None
    if count > 2:
        fetchMembersList()
        user = args[1]
        if not user in member_list:
            print_error('User (%s) not in network' % user)
    mergeUpstream(origin, user)
elif action == 'sync':
    user = None
    if count > 2:
        fetchMembersList()
        user = args[1]
        if not user in member_list:
            print_error('User (%s) not in network' % user)

    fetchUpstream(origin, user)
    mergeUpstream(origin, user)
elif action == 'build':
    if count > 2:
        buildControl(args[1])
    else:
        print_error('You must provide a component name')
elif action == 'docs' or action == 'doc':
    if count > 2:
        items = []
        for k,v in enumerate(args):
            if k > 0:
                items.append(v)
        buildDocs(items)
    else:
        print_error('You must provide at least one component name')
elif action == 'log':
    showLog()
elif action == 'network' or action == 'users' or action == 'forks':
    showNetwork()
elif action == 'commits':
    num = 5
    if count > 2:
        num = args[1]
    showCommits(num)
elif action == 'pullreq' or action == 'pullrequest':
    if count > 2:
        pullRequest(args[1])
    else:
        print bold(red('You need to supply a commit id.'))
        showCommits(5)
elif action == 'lint':
    if count > 2:
        items = []
        for k,v in enumerate(args):
            if k > 0:
                items.append(v)
        lintFiles(items)
    else:
        print_error('No file given')
else:
    ##Print Help
    print bold("This helper app will help you develop and contribute to YUI.")
    print " Usage: git yui [action]"
    print bold("     git yui up")
    print "         Pull the latest changes from yui HEAD into a branch called yui_[project]"
    print ""
    print bold("     git yui up [github username]")
    print "         Pull the latest changes from [username] HEAD into a branch called [username]_[project]"
    print ""
    print bold("     git yui merge")
    print "         Merge the yui_[project] branch back into the master branch"
    print ""
    print bold("     git yui merge [github username]")
    print "         Merge the [username]_[project] branch back into the master branch"
    print ""
    print bold("     git yui sync [github username]")
    print "         Runs git yui up, then git yui merge"
    print ""
    print bold("     git yui build [control]")
    print bold("         git yui build dd")
    print "         Run the ant processes needed to build the control"
    print "             (Requires builder to be one directory above this project)"
    print ""
    print bold("         git yui build all")
    print "         Run the build on all dir's in src."
    print "             (Requires builder to be one directory above this project)"
    print ""
    print bold("     git yui docs [control1] [control2]")
    print bold("         git yui docs dd")
    print bold("         git yui docs dd anim node yui")
    print "         Build the API docs for the specified modules"
    print "             (Requires yuidoc to be one directory above this project)"
    print ""
    print bold("         git yui docs all")
    print "         Build the API docs for all modules"
    print "             (Requires yuidoc to be one directory above this project)"
    print ""
    print bold("     git yui lint [path-to-file] [path-to-file] [path-to-file]")
    print "         Run JSLint on the supplied files."
    print "             (Requires builder to be one directory above this project)"
    print ""
    print bold("     git yui network|users|forks")
    print "         Show the list of forks for this project."
    print ""
    print bold("     git yui commits")
    print bold("     git yui commits nn")
    print "         Shows the last nn commits by you."
    print ""
    print bold("     git yui pullreq SHA1")
    print bold("     git yui pullrequest SHA1")
    print "         Submit a Pull Request to YUI for the provided SHA1."
    print ""
    print bold("     git yui log")
    print "         Show the error (stderr) output of the last command."
